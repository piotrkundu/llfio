<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLFIO: llfio_v2_xxx::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LLFIO
   &#160;<span id="projectnumber">v2.00 late beta</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacellfio__v2__xxx_1_1detail.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">llfio_v2_xxx::detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>attach_or_reinterpret</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_source_acceptable</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_source_acceptable&lt; llfio_v2_xxx::byte &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_source_chartype_acceptable</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_source_chartype_acceptable&lt; char &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_source_chartype_acceptable&lt; char16_t &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_source_chartype_acceptable&lt; char8_t &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>is_source_chartype_acceptable&lt; wchar_t &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>path_view_component_operator_slash_visitor</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>path_view_iterator</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>string_view_printer</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>thread_local_log_level_filter</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>value_pointer_fascade</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae8e18c4998e0aa92b606b3b88eec04a5"><td class="memItemLeft" align="right" valign="top"><a id="ae8e18c4998e0aa92b606b3b88eec04a5"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>char16_t</b> : unsigned short </td></tr>
<tr class="separator:ae8e18c4998e0aa92b606b3b88eec04a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a02c02d05e24d34c25324c192df11c0b4"><td class="memItemLeft" align="right" valign="top"><a id="a02c02d05e24d34c25324c192df11c0b4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LLFIO_TEMPLATE</b> (class T, class U) LLFIO_TREQUIRES(LLFIO_TPRED(std</td></tr>
<tr class="separator:a02c02d05e24d34c25324c192df11c0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c52ccdc38be135a374dbb4a7d1d466"><td class="memItemLeft" align="right" valign="top"><a id="a77c52ccdc38be135a374dbb4a7d1d466"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LLFIO_TEMPLATE</b> (class T) LLFIO_TREQUIRES(LLFIO_TPRED(std</td></tr>
<tr class="separator:a77c52ccdc38be135a374dbb4a7d1d466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e7d3f24db89f80ccebc240106110c0"><td class="memItemLeft" align="right" valign="top"><a id="a88e7d3f24db89f80ccebc240106110c0"></a>
global_dynamic_thread_pool_impl &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>global_dynamic_thread_pool</b> () noexcept</td></tr>
<tr class="separator:a88e7d3f24db89f80ccebc240106110c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5764bb77ec58ac60c6b92958a16043"><td class="memItemLeft" align="right" valign="top"><a id="a1f5764bb77ec58ac60c6b92958a16043"></a>
result&lt; <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>containing_directory</b> (optional&lt; std::reference_wrapper&lt; filesystem::path &gt;&gt; out_filename, const <a class="el" href="classllfio__v2__xxx_1_1handle.html">handle</a> &amp;h, const <a class="el" href="classfs__handle.html">fs_handle</a> &amp;fsh, <a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d) noexcept</td></tr>
<tr class="separator:a1f5764bb77ec58ac60c6b92958a16043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286da8606a5eb74cf26dcc9838c49ae8"><td class="memTemplParams" colspan="2"><a id="a286da8606a5eb74cf26dcc9838c49ae8"></a>
template&lt;class Dest , class Src &gt; </td></tr>
<tr class="memitem:a286da8606a5eb74cf26dcc9838c49ae8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fill_failure_info</b> (Dest &amp;dest, const Src &amp;src)</td></tr>
<tr class="separator:a286da8606a5eb74cf26dcc9838c49ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a6e1add1783bc959c4954ac92300f8"><td class="memTemplParams" colspan="2"><a id="a72a6e1add1783bc959c4954ac92300f8"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a72a6e1add1783bc959c4954ac92300f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log_inst_to_info</b> (const <a class="el" href="classllfio__v2__xxx_1_1handle.html">handle</a> *inst, const char *buffer)</td></tr>
<tr class="separator:a72a6e1add1783bc959c4954ac92300f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a53f79b32d63da588eb41da9fc9b78b"><td class="memItemLeft" align="right" valign="top"><a id="a8a53f79b32d63da588eb41da9fc9b78b"></a>
char &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>thread_local_log_level</b> ()</td></tr>
<tr class="separator:a8a53f79b32d63da588eb41da9fc9b78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0394a25491c4c22cb2311f2b1503c73"><td class="memItemLeft" align="right" valign="top"><a id="aa0394a25491c4c22cb2311f2b1503c73"></a>
result&lt; io_handle::registered_buffer_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>map_handle_allocate_registered_buffer</b> (size_t &amp;bytes) noexcept</td></tr>
<tr class="separator:aa0394a25491c4c22cb2311f2b1503c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa74d6fc6b9aef877233654f514041d"><td class="memItemLeft" align="right" valign="top"><a id="acaa74d6fc6b9aef877233654f514041d"></a>
result&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pagesize_from_flags</b> (section_handle::flag _flag) noexcept</td></tr>
<tr class="separator:acaa74d6fc6b9aef877233654f514041d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c9ba461630fe02b8c818df8b4f0402"><td class="memTemplParams" colspan="2"><a id="a24c9ba461630fe02b8c818df8b4f0402"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a24c9ba461630fe02b8c818df8b4f0402"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>constexpr_strlen</b> (const T *s) noexcept</td></tr>
<tr class="separator:a24c9ba461630fe02b8c818df8b4f0402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a020ef47a862a0d6ee2a8cb5b83000"><td class="memItemLeft" align="right" valign="top"><a id="af5a020ef47a862a0d6ee2a8cb5b83000"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>constexpr_strlen</b> (const byte *s) noexcept</td></tr>
<tr class="separator:af5a020ef47a862a0d6ee2a8cb5b83000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca839dcad90518be469393ff94a298c"><td class="memItemLeft" align="right" valign="top"><a id="aeca839dcad90518be469393ff94a298c"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>reencode_path_to</b> (size_t &amp;toallocate, char *dest_buffer, size_t dest_buffer_length, const llfio_v2_xxx::byte *src_buffer, size_t src_buffer_length, const std::locale *loc)</td></tr>
<tr class="separator:aeca839dcad90518be469393ff94a298c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cb1db78991ce362d7262bcf0e26921"><td class="memItemLeft" align="right" valign="top"><a id="ae7cb1db78991ce362d7262bcf0e26921"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>reencode_path_to</b> (size_t &amp;toallocate, char *dest_buffer, size_t dest_buffer_length, const char *src_buffer, size_t src_buffer_length, const std::locale *loc)</td></tr>
<tr class="separator:ae7cb1db78991ce362d7262bcf0e26921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa588880bc76221e6ec9715b70013105"><td class="memItemLeft" align="right" valign="top"><a id="afa588880bc76221e6ec9715b70013105"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>reencode_path_to</b> (size_t &amp;toallocate, char *dest_buffer, size_t dest_buffer_length, const wchar_t *src_buffer, size_t src_buffer_length, const std::locale *loc)</td></tr>
<tr class="separator:afa588880bc76221e6ec9715b70013105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f0c5568c83abca21bee9cd838f9542"><td class="memItemLeft" align="right" valign="top"><a id="ae7f0c5568c83abca21bee9cd838f9542"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>reencode_path_to</b> (size_t &amp;toallocate, char *dest_buffer, size_t dest_buffer_length, const char8_t *src_buffer, size_t src_buffer_length, const std::locale *loc)</td></tr>
<tr class="separator:ae7f0c5568c83abca21bee9cd838f9542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa126c294bd24c6170729c81a2d746cf7"><td class="memItemLeft" align="right" valign="top"><a id="aa126c294bd24c6170729c81a2d746cf7"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>reencode_path_to</b> (size_t &amp;toallocate, char *dest_buffer, size_t dest_buffer_length, const char16_t *src_buffer, size_t src_buffer_length, const std::locale *loc)</td></tr>
<tr class="separator:aa126c294bd24c6170729c81a2d746cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08446a93ea987bfbb45fd45f5fcd612"><td class="memItemLeft" align="right" valign="top"><a id="aa08446a93ea987bfbb45fd45f5fcd612"></a>
wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><b>reencode_path_to</b> (size_t &amp;toallocate, wchar_t *dest_buffer, size_t dest_buffer_length, const llfio_v2_xxx::byte *src_buffer, size_t src_buffer_length, const std::locale *loc)</td></tr>
<tr class="separator:aa08446a93ea987bfbb45fd45f5fcd612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e8ca5dbdce64395344f278844f1f7c"><td class="memItemLeft" align="right" valign="top"><a id="a78e8ca5dbdce64395344f278844f1f7c"></a>
wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><b>reencode_path_to</b> (size_t &amp;toallocate, wchar_t *dest_buffer, size_t dest_buffer_length, const char *src_buffer, size_t src_buffer_length, const std::locale *loc)</td></tr>
<tr class="separator:a78e8ca5dbdce64395344f278844f1f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bb62584e742b0b8397a63c333f7d59"><td class="memItemLeft" align="right" valign="top"><a id="a76bb62584e742b0b8397a63c333f7d59"></a>
wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><b>reencode_path_to</b> (size_t &amp;toallocate, wchar_t *dest_buffer, size_t dest_buffer_length, const wchar_t *src_buffer, size_t src_buffer_length, const std::locale *loc)</td></tr>
<tr class="separator:a76bb62584e742b0b8397a63c333f7d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43d4352669c668ec5882e7d953b3ea6"><td class="memItemLeft" align="right" valign="top"><a id="aa43d4352669c668ec5882e7d953b3ea6"></a>
wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><b>reencode_path_to</b> (size_t &amp;toallocate, wchar_t *dest_buffer, size_t dest_buffer_length, const char8_t *src_buffer, size_t src_buffer_length, const std::locale *loc)</td></tr>
<tr class="separator:aa43d4352669c668ec5882e7d953b3ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8e44c460932265c6c97b949eeaac92"><td class="memItemLeft" align="right" valign="top"><a id="aaf8e44c460932265c6c97b949eeaac92"></a>
wchar_t *&#160;</td><td class="memItemRight" valign="bottom"><b>reencode_path_to</b> (size_t &amp;toallocate, wchar_t *dest_buffer, size_t dest_buffer_length, const char16_t *src_buffer, size_t src_buffer_length, const std::locale *loc)</td></tr>
<tr class="separator:aaf8e44c460932265c6c97b949eeaac92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7461933c74794f79178f952c42083ed"><td class="memTemplParams" colspan="2"><a id="aa7461933c74794f79178f952c42083ed"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa7461933c74794f79178f952c42083ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_deleter</b> (...)</td></tr>
<tr class="separator:aa7461933c74794f79178f952c42083ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253dd24caea0c8a34a5260f3acf0b8ca"><td class="memItemLeft" align="right" valign="top"><a id="a253dd24caea0c8a34a5260f3acf0b8ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LLFIO_TEMPLATE</b> (class U) LLFIO_TREQUIRES(LLFIO_TEXPR(std</td></tr>
<tr class="separator:a253dd24caea0c8a34a5260f3acf0b8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1081a69ba488868ed42e8c7ce5bb1e17"><td class="memItemLeft" align="right" valign="top"><a id="a1081a69ba488868ed42e8c7ce5bb1e17"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>is_allocator</b> (...)</td></tr>
<tr class="separator:a1081a69ba488868ed42e8c7ce5bb1e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7e4173df2abeba7daed38f11bffc09"><td class="memItemLeft" align="right" valign="top"><a id="a6c7e4173df2abeba7daed38f11bffc09"></a>
constexpr float&#160;</td><td class="memItemRight" valign="bottom"><b>constexpr_float_allbits_set_nan</b> ()</td></tr>
<tr class="separator:a6c7e4173df2abeba7daed38f11bffc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ed947b141d970bb7ff5c21a6881d51"><td class="memTemplParams" colspan="2"><a id="ad6ed947b141d970bb7ff5c21a6881d51"></a>
template&lt;class Src &gt; </td></tr>
<tr class="memitem:ad6ed947b141d970bb7ff5c21a6881d51"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>append_path_info</b> (Src &amp;src, std::string &amp;ret)</td></tr>
<tr class="separator:ad6ed947b141d970bb7ff5c21a6881d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc31d7bab5faf3ee82e73854ff798b7"><td class="memItemLeft" align="right" valign="top"><a id="a0fc31d7bab5faf3ee82e73854ff798b7"></a>
result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>stat_from_symlink</b> (struct stat &amp;s, const <a class="el" href="classllfio__v2__xxx_1_1handle.html">handle</a> &amp;h) noexcept</td></tr>
<tr class="separator:a0fc31d7bab5faf3ee82e73854ff798b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Obtain a handle to the path <b>currently</b> containing this handle's file entry.</p>
<dl class="section warning"><dt>Warning</dt><dd>This call is <b>racy</b> and can result in the wrong path handle being returned. Note that unless <code>flag::disable_safety_unlinks</code> is set, this implementation opens a <code>path_handle</code> to the source containing directory, then checks if the file entry within has the same inode as the open file handle. It will retry this matching until success until the deadline given.</dd></dl>
<dl class="section user"><dt>Memory Allocations\n Calls current_path() and thus is both expensive and calls malloc many times.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>algorithm::cached_parent_handle_adapter&lt;T&gt;</code> which overrides this with a zero cost implementation, thus making unlinking and relinking very considerably quicker.</dd></dl>
<p>Relinks the current path of this open handle to the new path specified. If <code>atomic_replace</code> is true, the relink <b>atomically</b> and silently replaces any item at the new path specified. This operation is both atomic and matching POSIX behaviour even on Microsoft Windows where no Win32 API can match POSIX semantics.</p>
<p>Note that if <code>atomic_replace</code> is false, the operation <em>may</em> be implemented as creating a hard link to the destination (which fails if the destination exists), opening a new file descriptor to the destination, closing the existing file descriptor, replacing the existing file descriptor with the new one (this is to ensure path tracking continues to work), then unlinking the previous link. Thus <code>native_handle()</code>'s value <em>may</em> change. This is not the case on Microsoft Windows nor Linux, both of which provide syscalls capable of refusing to rename if the destination exists.</p>
<p>If the handle refers to a pipe, on Microsoft Windows the base path handle is ignored as there is a single global named pipe namespace. Unless the path fragment begins with <code>\</code>, the string <code>\??\</code> is prefixed to the name before passing it to the NT kernel API which performs the rename. This is because <code>\\.\</code> in Win32 maps onto <code>\??\</code> in the NT kernel.</p>
<dl class="section warning"><dt>Warning</dt><dd>Some operating systems provide a race free syscall for renaming an open handle (Windows). On all other operating systems this call is <b>racy</b> and can result in the wrong file entry being relinked. Note that unless <code>flag::disable_safety_unlinks</code> is set, this implementation opens a <code>path_handle</code> to the source containing directory first, then checks before relinking that the item about to be relinked has the same inode as the open file handle. It will retry this matching until success until the deadline given. This should prevent most unmalicious accidental loss of data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Base for any relative path. </td></tr>
    <tr><td class="paramname">path</td><td>The relative or absolute new path to relink to. </td></tr>
    <tr><td class="paramname">atomic_replace</td><td>Atomically replace the destination if a file entry already is present there. Choosing false for this will fail if a file entry is already present at the destination, and may not be an atomic operation on some platforms (i.e. both the old and new names may be linked to the same inode for a very short period of time). Windows and recent Linuxes are always atomic. </td></tr>
    <tr><td class="paramname">d</td><td>The deadline by which the matching of the containing directory to the open handle's inode must succeed, else <code>errc::timed_out</code> will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations\n Except on platforms with race free syscalls for renaming open handles (Windows), calls</dt><dd><code>current_path()</code> via <code>parent_path_handle()</code> and thus is both expensive and calls malloc many times.</dd></dl>
<p>Links the inode referred to by this open handle to the path specified. The current path of this open handle is not changed, unless it has no current path due to being unlinked.</p>
<dl class="section warning"><dt>Warning</dt><dd>Some operating systems provide a race free syscall for linking an open handle to a new location (Linux, Windows). On all other operating systems this call is <b>racy</b> and can result in the wrong inode being linked. Note that unless <code>flag::disable_safety_unlinks</code> is set, this implementation opens a <code>path_handle</code> to the source containing directory first, then checks before linking that the item about to be hard linked has the same inode as the open file handle. It will retry this matching until success until the deadline given. This should prevent most unmalicious accidental loss of data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Base for any relative path. </td></tr>
    <tr><td class="paramname">path</td><td>The relative or absolute new path to hard link to. </td></tr>
    <tr><td class="paramname">d</td><td>The deadline by which the matching of the containing directory to the open handle's inode must succeed, else <code>errc::timed_out</code> will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations\n Except on platforms with race free syscalls for renaming open handles (Windows), calls</dt><dd><code>current_path()</code> via <code>parent_path_handle()</code> and thus is both expensive and calls malloc many times.</dd></dl>
<p>Unlinks the current path of this open handle, causing its entry to immediately disappear from the filing system. On Windows before Windows 10 1709 unless <code>flag::win_disable_unlink_emulation</code> is set, this behaviour is simulated by renaming the file to something random and setting its delete-on-last-close flag. Note that Windows may prevent the renaming of a file in use by another process, if so it will NOT be renamed. After the next handle to that file closes, it will become permanently unopenable by anyone else until the last handle is closed, whereupon the entry will be eventually removed by the operating system.</p>
<dl class="section warning"><dt>Warning</dt><dd>Some operating systems provide a race free syscall for unlinking an open handle (Windows). On all other operating systems this call is <b>racy</b> and can result in the wrong file entry being unlinked. Note that unless <code>flag::disable_safety_unlinks</code> is set, this implementation opens a <code>path_handle</code> to the containing directory first, then checks that the item about to be unlinked has the same inode as the open file handle. It will retry this matching until success until the deadline given. This should prevent most unmalicious accidental loss of data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The deadline by which the matching of the containing directory to the open handle's inode must succeed, else <code>errc::timed_out</code> will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations\n Except on platforms with race free syscalls for unlinking open handles (Windows), calls</dt><dd><code>current_path()</code> and thus is both expensive and calls malloc many times. On Windows, also calls <code>current_path()</code> if <code>flag::disable_safety_unlinks</code> is not set. </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacellfio__v2__xxx.html">llfio_v2_xxx</a></li><li class="navelem"><a class="el" href="namespacellfio__v2__xxx_1_1detail.html">detail</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
